<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    canvas {
      display: block;
      margin: 20px auto;
    }
    .controls {
      margin-top: 20px;
    }
    input[type="range"] {
      width: 90%; /* Adjusted to 90% */
      margin-right: 10px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      margin: 5px;
    }
    #feedback {
      margin-top: 10px;
      font-size: 18px;
      color: green;
    }
    #averageDeviation {
      font-size: 18px;
      color: blue;
    }
    #recentDeviations {
      font-size: 16px;
      color: darkblue;
      text-align: left;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid lightgray;
      padding: 5px;
      background-color: white;
    }
    .footer {
      margin-top: 20px;
    }
    #cdfCanvas {
      margin: 20px auto;
    }
    .button-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
    }
    .slider-container {
      margin-top: 10px;
    }
    .overlap-value-container {
      display: inline-block;
      margin-left: 10px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div class="controls">
    <div class="button-container">
      <button id="newButton">New</button>
      <button id="confirmButton">Confirm</button>
      <div class="overlap-value-container">
        <span id="overlapValue">32/32</span>
        <span id="angleValue"></span>
      </div>
    </div>
    <div class="slider-container">
      <input type="range" id="overlapSlider" min="1" max="32" value="32" step="1">
    </div>
    <div id="feedback"></div>
  </div>

  <div class="footer">
    <div id="averageDeviation">Average Deviation: 0.0</div>
    <div id="recentDeviations"></div>
  </div>

  <canvas id="cdfCanvas"></canvas>

  <script>
    // Function to set up high-resolution canvas
    function setupHighResCanvas(canvasId, width, height) {
      const canvas = document.getElementById(canvasId);
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;

      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      return ctx;
    }

    // Canvas setup
    const gameCtx = setupHighResCanvas('gameCanvas', 400, 530);
    const cdfCtx = setupHighResCanvas('cdfCanvas', 400, 300);

    // Constants
    const DEFAULT_BALL_RADIUS = 60; // Default radius of the balls
    const CANVAS_WIDTH = gameCtx.canvas.width / (window.devicePixelRatio || 1);
    const CANVAS_HEIGHT = gameCtx.canvas.height / (window.devicePixelRatio || 1);

    let correctOverlap = Math.floor(Math.random() * 32) + 1; // Random value between 1 and 32
    let objectBallOnLeft = Math.random() < 0.5; // Randomly decide if the object ball is on the left or right
    let ballRadius = getRandomBallRadius(); // Randomize ball radius
    let ballDiameter = ballRadius * 2;
    let objectBallY = getRandomObjectBallY(); // Randomize object ball Y position
    let userChoices = []; // Array to store all user choices with their corresponding correctOverlap
    let showVerticalLine = false; // Flag to control whether to draw the vertical line

    function getRandomObjectBallY() {
      const minDistanceFromCueBallCenter = ballDiameter;
      const cueBallY = (CANVAS_HEIGHT * 3) / 4;
      const minY = Math.max(ballRadius, cueBallY - CANVAS_HEIGHT + minDistanceFromCueBallCenter);
      const maxY = Math.min(CANVAS_HEIGHT - ballRadius, cueBallY - minDistanceFromCueBallCenter);
      return Math.random() * (maxY - minY) + minY;
    }

    function getRandomBallRadius() {
      return Math.random() * (DEFAULT_BALL_RADIUS - (DEFAULT_BALL_RADIUS * 2 / 3)) + (DEFAULT_BALL_RADIUS * 2 / 3);
    }

    function drawScene(ghostBallX, ghostBallY, userChosenX) {
      gameCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Calculate positions
      const cueBallX = CANVAS_WIDTH / 2;
      const cueBallY = (CANVAS_HEIGHT * 3) / 4;
      const horizontalDistance = ballDiameter * (1 - correctOverlap / 32);
      const objectBallX = objectBallOnLeft ? cueBallX - horizontalDistance : cueBallX + horizontalDistance;

      // Set stroke style and line width for consistency
      gameCtx.strokeStyle = 'black';
      gameCtx.lineWidth = 1;

      // Draw cue ball
      gameCtx.beginPath();
      gameCtx.arc(cueBallX, cueBallY, ballRadius, 0, Math.PI * 2);
      gameCtx.fillStyle = 'white';
      gameCtx.fill();
      gameCtx.stroke();

      // Draw object ball
      gameCtx.beginPath();
      gameCtx.arc(objectBallX, objectBallY, ballRadius, 0, Math.PI * 2);
      gameCtx.fillStyle = 'red';
      gameCtx.fill();
      gameCtx.stroke();

      // Draw cue line
      gameCtx.beginPath();
      gameCtx.moveTo(cueBallX, cueBallY + ballRadius);
      gameCtx.lineTo(cueBallX, cueBallY + ballRadius + 50);
      gameCtx.stroke();

      // Draw vertical dashed line at cue ball's x-coordinate if needed
      if (showVerticalLine) {
        gameCtx.setLineDash([5, 5]);
        gameCtx.strokeStyle = 'gray';
        gameCtx.lineWidth = 1;
        gameCtx.beginPath();
        gameCtx.moveTo(cueBallX, 0);
        gameCtx.lineTo(cueBallX, CANVAS_HEIGHT);
        gameCtx.stroke();
        gameCtx.setLineDash([]);
      }

      // Draw user chosen ball if provided coordinates
      if (userChosenX !== undefined) {
        drawUserChosenBall(userChosenX, objectBallY);
      }

      // Draw ghost ball if provided coordinates
      if (ghostBallX !== undefined && ghostBallY !== undefined) {
        drawGhostBall(ghostBallX, ghostBallY);
      }
    }

    function updateOverlapDisplay(value) {
      const actualValue = objectBallOnLeft ? 33 - value : value;
      document.getElementById('overlapValue').textContent = `${actualValue}/32`;
      const angle = Math.asin(1 - actualValue / 32) * (180 / Math.PI);
      document.getElementById('angleValue').textContent = ` (${angle.toFixed(1)}째)`;
    }

    function calculateAngleFromOverlap(overlap) {
      return Math.asin(1 - overlap / 32) * (180 / Math.PI);
    }

    function calculateAverageDeviation() {
      if (userChoices.length === 0) return 0;
      const recentChoices = userChoices.slice(-5); // Get the last 5 choices
      const totalDeviation = recentChoices.reduce((sum, choice) => sum + Math.abs(choice.choice - choice.correctOverlap), 0);
      return totalDeviation / recentChoices.length;
    }

    function updateRecentDeviations() {
      const deviationsDiv = document.getElementById('recentDeviations');
      const recentChoices = userChoices.slice(-5); // Get the last 5 choices
      const deviations = recentChoices.map(choice => `| Choice: ${choice.choice} | Correct: ${choice.correctOverlap} | Deviation: ${Math.abs(choice.choice - choice.correctOverlap)} |`);
      deviationsDiv.innerHTML = deviations.join('<br>');
    }

    function drawGhostBall(x, y) {
      // Set stroke style and line width for ghost ball
      gameCtx.setLineDash([5, 5]); // Dashed line
      gameCtx.strokeStyle = 'blue';
      gameCtx.lineWidth = 2;

      // Draw ghost ball
      gameCtx.beginPath();
      gameCtx.arc(x, y, ballRadius, 0, Math.PI * 2);
      gameCtx.stroke();

      // Reset line dash
      gameCtx.setLineDash([]);
    }

    function drawUserChosenBall(x, y) {
      // Set stroke style and line width for user chosen ball
      gameCtx.setLineDash([5, 5]); // Dashed line
      gameCtx.strokeStyle = 'green';
      gameCtx.lineWidth = 2;

      // Draw user chosen ball
      gameCtx.beginPath();
      gameCtx.arc(x, y, ballRadius, 0, Math.PI * 2);
      gameCtx.stroke();

      // Reset line dash
      gameCtx.setLineDash([]);
    }

    function checkAnswer(userChoice) {
      const feedbackDiv = document.getElementById('feedback');
      const actualChoice = objectBallOnLeft ? 33 - userChoice : userChoice;
      const correctAngle = calculateAngleFromOverlap(correctOverlap).toFixed(1);
      const chosenAngle = calculateAngleFromOverlap(actualChoice).toFixed(1);

      if (actualChoice === correctOverlap) {
        feedbackDiv.textContent = `Correct! The overlap is ${correctOverlap}/32 (${correctAngle}째).`;
        feedbackDiv.style.color = 'green';
      } else {
        feedbackDiv.textContent = `Incorrect! The correct overlap was ${correctOverlap}/32 (${correctAngle}째). You chose ${actualChoice}/32 (${chosenAngle}째).`;
        feedbackDiv.style.color = 'red';
      }

      // Store the user choice along with the current correctOverlap
      userChoices.push({ choice: actualChoice, correctOverlap: correctOverlap });

      // Calculate average deviation
      const averageDeviation = calculateAverageDeviation();
      document.getElementById('averageDeviation').textContent = `Average Deviation: ${averageDeviation.toFixed(1)}`;

      // Update recent deviations
      updateRecentDeviations();

      // Redraw the scene including the ghost ball and vertical line
      const cueBallX = CANVAS_WIDTH / 2;
      const cueBallY = (CANVAS_HEIGHT * 3) / 4;
      const horizontalDistance = ballDiameter * (1 - correctOverlap / 32);
      const objectBallX = objectBallOnLeft ? cueBallX - horizontalDistance : cueBallX + horizontalDistance;

      // Calculate ghost ball position
      const ghostBallX = cueBallX;
      const distanceBetweenCenters = ballDiameter;
      const deltaY = Math.sqrt(distanceBetweenCenters ** 2 - (objectBallX - ghostBallX) ** 2);
      const ghostBallY1 = objectBallY + deltaY;
      const ghostBallY2 = objectBallY - deltaY;

      // Choose the lower ghost ball Y coordinate
      const ghostBallY = Math.max(ghostBallY1, ghostBallY2);

      // Calculate user chosen ball position
      const userChosenHorizontalDistance = ballDiameter * (1 - actualChoice / 32);
      const userChosenX = objectBallOnLeft ? cueBallX - userChosenHorizontalDistance : cueBallX + userChosenHorizontalDistance;

      showVerticalLine = true; // Show the vertical line after confirming
      drawScene(ghostBallX, ghostBallY, userChosenX);

      // Update CDF plot
      updateCDFPlot();
    }

    function newQuestion() {
      correctOverlap = Math.floor(Math.random() * 32) + 1; // Generate a new random correct overlap value
      objectBallOnLeft = Math.random() < 0.5; // Randomly decide if the object ball is on the left or right
      ballRadius = getRandomBallRadius(); // Randomize ball radius
      ballDiameter = ballRadius * 2;
      objectBallY = getRandomObjectBallY(); // Randomize object ball Y position
      const sliderValue = objectBallOnLeft ? 1 : 32; // Set slider value based on object ball position
      document.getElementById('overlapSlider').value = sliderValue; // Reset slider to default value
      updateOverlapDisplay(sliderValue); // Update displayed overlap value
      document.getElementById('feedback').textContent = ''; // Clear feedback message
      showVerticalLine = false; // Hide the vertical line when starting a new question
      drawScene(); // Redraw the scene without ghost ball or vertical line

      // Update CDF plot
      updateCDFPlot();
    }

    function updateCDFPlot() {
      const deviations = userChoices.map(choice => Math.abs(choice.choice - choice.correctOverlap));
      deviations.sort((a, b) => a - b);

      const n = deviations.length;
      const dataPoints = deviations.map((deviation, index) => ({
        x: deviation,
        y: (index + 1) / n
      }));

      cdfCtx.clearRect(0, 0, cdfCtx.canvas.width, cdfCtx.canvas.height);

      // Check if there are any data points to plot
      if (dataPoints.length === 0) {
        return;
      }

      // Define axis limits and scales
      const xAxisMin = 0;
      const xAxisMax = 10;
      const yAxisMin = 0;
      const yAxisMax = 1;
      const xAxisLength = 300;
      const yAxisLength = 200;
      const startX = 50;
      const startY = 250;

      // Draw axes
      cdfCtx.beginPath();
      cdfCtx.moveTo(startX, startY);
      cdfCtx.lineTo(startX + xAxisLength, startY);
      cdfCtx.moveTo(startX, startY);
      cdfCtx.lineTo(startX, startY - yAxisLength);
      cdfCtx.stroke();

      // Label axes
      cdfCtx.font = '14px Arial';
      cdfCtx.textAlign = 'center';
      cdfCtx.fillText('Deviation', startX + xAxisLength / 2, startY + 40); // Adjusted vertical position
      cdfCtx.save();
      cdfCtx.translate(startX - 30, startY - yAxisLength / 2);
      cdfCtx.rotate(-Math.PI / 2);
      cdfCtx.textAlign = 'center';
      cdfCtx.fillText('Cumulative Probability', 0, 0);
      cdfCtx.restore();

      // Draw x-axis ticks and labels
      for (let i = 0; i <= xAxisMax; i += 2) {
        const tickX = startX + (i / xAxisMax) * xAxisLength;
        cdfCtx.beginPath();
        cdfCtx.moveTo(tickX, startY);
        cdfCtx.lineTo(tickX, startY + 5);
        cdfCtx.stroke();
        cdfCtx.fillText(i.toString(), tickX, startY + 20);
      }

      // Draw y-axis ticks and labels
      for (let j = 0; j <= 1; j += 0.2) {
        const tickY = startY - (j / yAxisMax) * yAxisLength;
        cdfCtx.beginPath();
        cdfCtx.moveTo(startX, tickY);
        cdfCtx.lineTo(startX - 5, tickY);
        cdfCtx.stroke();
        cdfCtx.fillText(j.toFixed(1), startX - 15, tickY + 7); // Adjusted horizontal position
      }

      // Draw CDF line
      cdfCtx.beginPath();
      cdfCtx.moveTo(startX + (dataPoints[0].x / xAxisMax) * xAxisLength, startY - (dataPoints[0].y / yAxisMax) * yAxisLength);
      for (let i = 1; i < dataPoints.length; i++) {
        cdfCtx.lineTo(startX + (dataPoints[i].x / xAxisMax) * xAxisLength, startY - (dataPoints[i].y / yAxisMax) * yAxisLength);
      }
      cdfCtx.strokeStyle = 'blue';
      cdfCtx.lineWidth = 2;
      cdfCtx.stroke();
    }

    // Initialize game
    newQuestion(); // Call newQuestion to initialize the slider correctly

    // Event listeners
    document.getElementById('overlapSlider').addEventListener('input', (event) => {
      updateOverlapDisplay(event.target.value);
    });

    document.getElementById('confirmButton').addEventListener('click', () => {
      const userChoice = parseInt(document.getElementById('overlapSlider').value, 10);
      checkAnswer(userChoice);
    });

    document.getElementById('newButton').addEventListener('click', newQuestion);
  </script>
</body>
</html>



